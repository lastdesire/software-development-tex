\input{preamble.tex}
\usepackage{pgfplots}
\pgfplotsset{compat=1.9}
\pgfplotsset{model/.style = {blue, samples = 100}}
\pgfplotsset{experiment/.style = {red}}

\begin{document}
    \Header

    \BeginConspect

    \Section{Разработка ПО}{}{Гагин Артур}

    \Subsection{Требования, виды требований, стейкхолдеры. Бизнес-анализ, системный анализ}

    \begin{Def}[Требования]
        Требования --- это спецификация того, что должно быть реализовано. Это описание того, как система должна вести, описание ее свойств или атрибутов. Они могут вносить ограничения на процесс разработки системы.
    \end{Def}
    
    \begin{Rem}
        Отражение взгляда на систему заказчиков, разработчиков и пользователей (стейкхолдеров).
    \end{Rem}

    \begin{Def}[Виды требований]
        Фундаментально, требования разделяют на функциональные и нефункциональные требования.

        \begin{itemize}
            \item Функциональные требования --- требования, которые отвечают на вопросы о том, что система должна сделать с точки зрения алгоритмов.
            \item Нефункциональные требования --- все требования, что не относятся к алгоритмам системы.
        \end{itemize}
        
        Приведем следующий пример с приложением, где можно покупать билеты на электрички. Требование уметь покупать билеты на электрички является функциональным требованием. С другой стороны, требование к удобному интерфейсу, например, не является функциональным требованием.

        Вообще разница может показаться довольно размытой. Но часто проводят следующую грань: все, что относится к алгоритмам, является функциональными требованиями, а все, что относится к тому, как система выглядит и какими свойствами обладает, является нефункциональными требованиями.

        Тем не менее, данная классификация не является единственной.

        \begin{itemize}
            \item Бизнес-требования. Это такие высокоуровневые требования, которые позволяют достигать целей с точки зрения бизнеса.

            \item Бизнес-правила. Более мелкие требования по сравнению с бизнес-требованиями.

            \item Ограничения.

            \item Требования по внешним интерфейсам. Как система взаимодействует с конкретным пользователем и внешними по отношению к ней системами (источники и получатели данных, например).

            \item Возможности системы (фичи). То, что в широком смысле она умеет делать в рамках реализации бизнес-требований. Например, добавлять определенные маршруты в избранные.

            \item Требования по качеству. Например, покрытие всего кода тестами с определенным процессом, бесперебойная работа системы под определенной нагрузкой.

            \item Требования, выдвигаемые к системе в целом. То есть, атрибуты, которыми обладает не отдельный компонент системы, а она вся. Например, доступность системы в течение 99.99\% времени.

            \item Пользовательские требования. Те требования, которые выдвинули пользователи, очевидно. 
        \end{itemize}
    \end{Def}

    \begin{Def}[Стейкхолдеры]
        Стейкхолдеры --- это люди, являющиеся источниками требований. Как правило, они заинтересованы в разрабатываемой системе.
        \begin{itemize}
            \item Заказчики.
            \item Разработчики.
            \item Пользователи, операторы.
            \item Бенефициары (те, кто получит какую-то выгоду от продажи продукта).
            \item Ответственные за покупку, продажу, установку системы.
            \item Регулирующие органы.
            \item Конкуренты.
            \item Вертикально интегрированные организации. Например, если компания занимается нефтепереработкой, то компании по нефтедобыче и нефтепродаже являются таковыми.
            \item Партнеры по горизонтальной интеграции. Похожи на конкурентов, но являются дружественными компаниями.
        \end{itemize}
    \end{Def}

    \begin{Rem}
        Существует несколько способов документирования требований.
        \begin{itemize}
            \item Software Requirements Specification.
            \item Use cases.
            \item User stories.
            \item ...
        \end{itemize}
    \end{Rem}

    \Subsection{Software Requirements Specification: назначение, общая структура. Перспектива продукта}

    \Subsection{Software Requirements Specification: функции продукта, характеристики пользователя, ограничения}
    
    \Subsection{Software Requirements Specification: допущения, внешние интерфейсы, функции}
    
    \Subsection{Software Requirements Specification: атрибуты программной системы, верификация}

    \begin{Def}[SRS]
        SRS $\sim$ Техническое задание.
    \end{Def}

    \begin{Def}[Структура SRS]
        Рассмотрим структуру SRS.
        \begin{itemize}
            \item \textbf{SRS overview} (обзор SRS). Краткое описание документа: этот документ содержит ..., разрабатывается ..., для ..., и т. д.
            
            \item Purpose (цель, ради которой система разрабатывается). Какие бизнес-задачи решает данная система. Здесь это все расписывается не очень подробно. 
            
            \item Scope (границы проекта). Что система должна делать, а чего не должна и не будет (на высоком уровне).
            
            \item \textbf{Product perspective} (перспектива продукта). Что из себя представляет продукт.
            \begin{enumerate}
                \item System interfaces. Как происходит взаимодействие с системным программным обеспечением.
                \item User interfaces. Как пользователи взаимодействуют с системой.
                \item Hardware interfaces. Как происходит взаимодействие с железом.
                \item Software interfaces. Как система взаимодействует с какими-то программами (библиотеками), например. 
                \item Communications interfaces. Как происходит взаимодействие с внешним миром. Например, с сетью.
                \item Memory. В какие ограничения по памяти укладывается система.
                \item Operations. Что система позволяет сделать с технической точки зрения. Например, создавать документы. (Еще пример с требованием выгрузки данных раз в какое-то время тоже можно отнести сюда).
                \item Site adaptation requirements. Что необходимо донастроить или докупить на месте развертывания системы.
                \item Interfaces with services. С какими внешними сервисами система взаимодействует.
            \end{enumerate}

            \item \textbf{Product functions}. Описывается, что продукт должен уметь делать, какие функции выполнять (уже более подробно). Вообще все, что удовлетворять бизнес-цели.

            \item \textbf{User characteristics}. Каких пользователей мы ожидаем для нашей системы. 

            \item \textbf{Limitations} (ограничения).
            \begin{enumerate}
                \item Законодательные требования.
                \item Hardware limitations. Минимальные системные требования, рекомендуемые, ...
                \item Interfaces to other applications. API, который мы предоставляем наружу.
                \item Parallel operation. Может ли система работать параллельно.
                \item Audit functions (функции по аудиту). Некий организационный контроль за тем, что бизнес-требования выполняются.
                \item Control functions. Контроль за тем, что пользователю разрешено делать, а что запрещено, например. Контроль за какими-то подозрительными действиями внутри системы.
                \item Higher-order language requirements. Здесь указывается, например, парадигма программирования. Речь также про языки и про то, что стоит выражаться аккуратно, возможно.
                \item Signal handshake protocols. То, как мы передаем данные, например (TCP/IP).
                \item Quality requirements (требования по качеству). Например, бесперебойная работа одного пользователя на определенной конфигурации железа (165 кадров в секунду, например).
                \item Criticality of the application (критичность приложения). Качественная работа одного приложения 24/7 может быть намного критичнее другого. 
                \item Safety and security considerations. 
                \item Physical and mental considerations (ограничения по физическим и умственным соображениям). Возможно ли систему использовать людям с ограниченными возможностями.
            \end{enumerate} 

            \item \textbf{Assumptions and dependencies} (допущения и зависимости). Здесь описываются некие аксиомы, которые помогают при разработке приложения. Например, можно считать, что за три года браузеры, которые используются, не устареют. Используемые библиотеки также могут быть описаны здесь. Какие-то внешние зависимости, над которыми контроля не имеется.

            \item Apportioning of requirements.

            \item Specified requirements.

            \item \textbf{External interfaces} (внешние интерфейсы). Здесь интерфейсы расписываются более подробно по сравнению с пунктами перспектив продукта и его ограничений. Описываются внешние интерфейсы. Например, какие входы и выходы ожидаем (в широком смысле). Например, форматы файлов, которые поступают на вход.

            \item \textbf{Functions} (функции). Здесь функции расписываются более подробно по сравнению с пунктами перспектив продукта и его ограничений. Происходит детализация алгоритмики.
            \begin{enumerate}
                \item Validity checks on the inputs (проверка входных данных на корректность).
                \item Описание последовательности операций.
                \item Обработки исключений.
                \item Эффект входных параметров.
                \item Как вывод связан со входом.
            \end{enumerate}

            \item ...

            \item \textbf{Software system attributes} (атрибуты программной системы). Какими словами можно описать систему. Качества.
            \begin{enumerate}
                \item Reliability (надежность и что под ней понимается).
                \item Availability (доступность: всем категориям лиц, например).
                \item Security (безопасность: что данные никуда не утекают, например).
                \item Maintainability (обслуживаемость).
                \item Portability  (переносимость с одного железа на другой).
            \end{enumerate}

            \item \textbf{Verification} (верификация). Описание проверки всех требований выше. Как именно проверяется, что требования выполнены.

            \item Supporting information.
        \end{itemize}
    \end{Def}

    \begin{Rem}
        В настоящее время документы с полным содержанием SRS пишутся редко.
    \end{Rem}

    \Subsection{(Use cases) Прецеденты: назначение, диаграмма прецедентов, форматы описания}

    \begin{Def}[Система]
        Система --- разрабатываемая программная или программно-апаратная система. То, что разрабатывается.
    \end{Def}

    \begin{Def}[Актор]
        Актор --- внешняя по отношению к системе сущность, которая или с которой взаимодействует система.
    \end{Def}

    \begin{Def}[Прецедент]
        Прецедент --- последовательность действий между актором (-ами) и системой, приводящая к достижению какой-либо цели.
    \end{Def}

    \begin{Rem}
        Изначально, для документирования в форме прецедентов использовалась UML диаграмма прецедентов.
    \end{Rem}

    \begin{Def}[Форматы описания Use Cases]
        Существует пара подходов к описанию самого прецедента.

        \begin{itemize}
            \item Кобёрн.
            \begin{itemize}
                \item Title (цель).
                \item Primary Actor (первичный актор, который инициирует этот прецедент).
                \item Scope (описание той части системы, с которой актор начинает взаимодействовать).
                \item Level (уровень предецента: 
                насколько важно его реализовывать).
                \item Story (что происходит в системе, можно неформально).
            \end{itemize}
            
            \item Фаулер.
            \begin{itemize}
                \item Title.
                \item Main Success Scenario (главный сценарий успеха). Нумерованный список шагов, по которому достигается цель.
                \item Extensions (расширения). Список, в котором описывается, на каком шаге что-то может пойти не так (показываем, что будет происходить в другом случае).
            \end{itemize}
        \end{itemize}
    \end{Def}

    \begin{Rem}[Уровни прецедентов]
        Уровней прецедентов существует несколько.
        \begin{itemize}
            \item Very high summary.
            \item Summary.
            \item User Goal.
            \item Subfunction.
            \item Too Low.
        \end{itemize}
    \end{Rem}

    \begin{Rem}
        В отличие от SRS, подход с прецедентами фокусируется на том, как система взаимодействует с пользователями, как она внутри себя работает и что делает. Основной фокус делается на функциональных требованиях. UI, например, тут не описать.
    \end{Rem}

    \Subsection{(User stories) Пользовательские истории: назначение, общий шаблон, виды}

    \begin{Rem}
        Подход с SRS хорош тем, что он показывает все множество требований к системе в едином документе. Подход с прецедентами хорош тем, что очень хорошо показывает алгоритмику. Подход с пользовательскими историями показывают, что требования могут со временем эволюционировать, становиться более подробными, изменяться.
    \end{Rem}
    
    \begin{Def}[Пользовательская история]
        Пользовательская история --- это описание функциональности ПО простыми, общими словами, составленное с точки зрения конечного пользователя. Она пишется с целью разъяснить, как именно функциональность принесет пользу клиенту.
    \end{Def}

    \begin{Rem}
        Это не совсем требование, а скорее его обсуждение.
    \end{Rem}

    \begin{Rem}
        Выяснение требований в данном случае --- это процесс, который не прекращается. С течением времени мы выявляем все новые и новые требования к системе.
    \end{Rem}

    \begin{Rem}[Шаблон]
        Как <роль пользователя>, я хочу получить <фича> с целью <цель>.
    \end{Rem}

    \begin{Rem}
        Специальные собрания по проработке US --- груминги (planning poker).
    \end{Rem}
    
    \begin{Def}[Виды пользовательских историй]
        Выделяют разные виды пользовательских историй.
        \begin{itemize}
            \item Эпики (очень большие пользовательские истории, разработка которых может занимать недели и месяцы, поэтому они разбиваются на подзадачи).
            \item Задачи.
            \item Ошибки.
            \item Исследовательские задачи (они не всегда внедряются в систему).
        \end{itemize}
    \end{Def}

    \begin{Rem}
        Пользовательские истории помечаются сложностью выполнения и важностью внедрения.
    \end{Rem}

    \Subsection{Планирование разработки. Треугольник(-и) управления проектами}

    \begin{Rem}
        Предположим, что требования собраны. Далее их нужно реализовывать. Багтрекер здесь может помочь (например, Trello), но на деле все более сложно. Планирование разработки --- отдельный вид деятельности. 

        \begin{itemize}
            \item Ответственность лежит на менеджере проекта и руководителях команд (тим-лидах). 
            
            Менеджер проекта --- человек, который управляет всем процессом разработки на высоком уровне, отвечая за то, чтобы проект на этом же самом высоком уровне был завершен (проект реализован в срок, сделано то, что нужно, уложились в бюджет). 

            При этом на тим-лида сваливаются задачи не столько стратегического хода проекта, сколько тактического, повседневного: кто получает какие задачи, что с ними делать и т.д.
            \item Поиск и предоставление необходимых ресурсов (менеджер проекта).
            \item Определение методологии разработки (менеджер проекта). 
            \item Определение политики выпуска версий (менеджер проекта).
            \item Определение границ версий (менеджер проекта).
            \item Разбивка на задачи (и оценка трудоемкости), установка приоритетов, назначение задач командам и людям (менеджер проекта или тим-лид).
            \item Контроль за выполнением (менеджер проекта).
        \end{itemize}
    \end{Rem}

    \begin{Rem}
        Аккаунт менеджер --- менеджер, который работает с несколькими проектами (менеджер менеджеров).
    \end{Rem}

    \begin{Def}[Треугольник управления проектами]
        В управлении проектами существует классический треугольник, с помощью которого подчеркивается следующий тезис: можно варьировать цену, время и объем задачи, но не все три пункта одновременно.
    \end{Def}

    \begin{Def}[Закон Брукса]
        Добавление рабочей силы к позднему программному проекту делает его более поздним.
    \end{Def}

    \Subsection{Методологии разработки}

    \begin{Rem}
        Вспомним несколько известных методологий разработки.
        \begin{itemize}
            \item Водопадная модель.
            \item Спиральная модель.
            \item Scrum.
            \item Kanban (Scrum на минималках: убраны люди, которые относятся к методологии Scrum, например, Scrum-мастера).
        \end{itemize}
    \end{Rem}

    \Subsection{Политика выпуска версий, определение границ версий, разбивка на задачи}

    \begin{Rem}[Политика выпуска версий]
        Политика выпуска версий --- уровень рассуждения менеджера проекта. Есть несколько подходов.
        \begin{itemize}
            \item Крупные релизы редко.
            \item Крупные релизы редко, более мелкие в рамках большого релиза --- чаще.
            \item Обновления последней версии время от времени (регулярные, нерегулярные).
            \item Периодическая фиксация версия, обновления последней версии время от времени (регулярные, нерегулярные).
        \end{itemize}
        
        Также сюда входит ответ на вопрос о том, на какие версии распространяется поддержка.
    \end{Rem}

    \begin{Rem}[Определение границ версий]
        Границы устанавливаются исходя из следующих пунктов.
        \begin{itemize}
            \item К какому сроку необходимо сделать работу.
            \item Сколько денег выделено на работу.
            \item Какая функциональность требуется заказчику.
            \item Какой уровень качества нужен заказчику.
        \end{itemize}
    \end{Rem}

    \begin{Rem}[Разбивка на задачи]
        Чтобы из требований получить конкретный план действий, обсуждают следующие пункты.
        \begin{itemize}
            \item Что конкретно нужно сделать.
            \item Какие нужны ресурсы (материальные и нематериальные).
            \item Оценка трудоемкости.
            \item Назначение приоритета.
            \item Назначение ответственных.
        \end{itemize}

        Для разбивки на задачи есть Work Breakdown Structure, например.
    \end{Rem}

    \Subsection{Work Breakdown Structure}

    \begin{Def}[Work Breakdown Structure]
        Иерархическая структура работ --- способ декомпозиции проекта и диаграмма, соответствующая этой декомпозиции.

        Диаграмма выглядит следующим образом. На самом верхнем уровне (в корне) находится результат, которого мы хотим достичь. Из корня появляются части, необходимые для выполнения этой задачи. Из каждой из частей могут появляться другие части.

        \begin{itemize}
            \item Самый верхний уровень --- общий объем работы, весь проект.
            \item Далее --- высокоуровневые составные части проекта.
            \item Ниже --- части частей.
        \end{itemize}
    \end{Def}

    \begin{Rem}
        Стоит понимать, что результат проект формулируется с точки зрения отчуждаемых артефактов (то, что сделано и может быть передано, например, программа).

        Строго говоря, WBS не является to-do list'ом, поскольку со временем понимание о проекте растет, могут отвалиться какие-либо части, которые оказываются не очень-то и нужными. Может и наоборот, добавиться что-то новое.

        Также это не mind map.

        На всех уровнях работает правило 100\%: сумма объема дочерних узлов в точности равна объему родительского узла.

        В WBS входит все, на что приходится тратить время, даже, например, на общение с заказчиком.
    \end{Rem}

    \begin{Rem}
        Дробить задачу требуется настолько сильно, насколько логично.

        Также существует мнение, что если на задачу уходит более 80 часов, то, скорее всего, задача содержит в себе какие-то составные части.

        Еще один вариант --- это дробление на такие задачи, оценка работы каждой из которых не будет превышать отчетного периода.
    \end{Rem}

    \begin{Rem}
        Определяется, что надо сделать, но не как.
    \end{Rem}

    \begin{Rem}[Как делать]
        После того, как определились, что делать, необходимо договориться о том, как делать.
        \begin{itemize}
            \item Собрать все важные документы.
            \item Определить ключевых участников команды (аналитики, программисты, тестировщики, менеджер, ...).
            \item Определить элементы первого уровня (фазовая разработка или артефактная).
            \item Рекурсивно повторить предыдущий шаг для каждого элемента первого уровня.
            \item Создать словарь WBS (этапы работ, риски, стоимость, границы, и т. д.).
            \item Составить диаграмму Ганта.
        \end{itemize}
    \end{Rem}
    
    \Subsection{Подходы к оценке трудоёмкости}

    \begin{Rem}
        Существует несколько подходов к оценке трудоемкости.
        \begin{itemize}
            \item PERT. Использует математические методы. Основывается на нормальном распределении.

            Берем три оценки: оптимистическую, нормальную (наиболее вероятный исход), пессимистическую.

            Оценка трудоемкости строится как оценка нормального распределения. Математическое ожидание вычисляется следующим образом (грубоватая оценка математического ожидания нормальной случайной величины): $$\mu = \frac{optimistic + 4 * normal + pessimistic}{6}.$$
            Стандартное отклонение: $$\sigma = \frac{pessimistic - optimistic}{6}.$$ Оно позволяет оценить наиболее вероятный разброс по времени работ.

            Для последовательности задач:
            $$\mu_{seq} = \sum \mu_{task};$$
            $$\sigma_{seq} = \sqrt{\sum \sigma_{task}^2}.$$

            \item Широкополосный дельфийский метод. 

            Группа экспертов обсуждает и оценивает задачу до тех пор, пока не придет к согласию (абсолютность и формальная подкрепленность не совсем обязательна).

            \item Planning poker.

            Игра.

            Каждый участник одновременно выкладывает свою карточку.

            Предложившие максимальное и минимальное значение объясняют свой выбор.

            Очки могут быть, например, не в человеко-днях, а, например, в спринтах.
        \end{itemize}
    \end{Rem}
\end{document}